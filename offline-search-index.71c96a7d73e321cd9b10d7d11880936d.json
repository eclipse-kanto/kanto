[{"body":"Before you begin The containerd Debian package is required. You can install it manually or run:\ncurl -fsSL https://github.com/eclipse-kanto/kanto/raw/main/quickstart/install_ctrd.sh | sh Install Eclipse Kanto Choose the Eclipse Kanto Debian package for your target device architecture from the ones available at the project’s GitHub Releases page. Download and install it via executing the following (adjusted to your package name):\nwget https://github.com/eclipse-kanto/kanto/releases/download/v0.1.0-M1/kanto_0.1.0-M1_linux_x86_64.deb \u0026\u0026 \\ sudo apt install ./kanto_0.1.0-M1_linux_x86_64.deb Verify It’s important to check if all the services provided by the Eclipse Kanto package are up and running successfully. You can quickly do that via executing:\nsystemctl status \\ suite-connector.service \\ container-management.service \\ software-update.service \\ file-upload.service All listed services must be in an active running state.\nWhat’s next Explore via Eclipse Hono\nExplore via Bosch IoT Device Management\n","categories":"","description":"Run Eclipse Kanto on your edge device.\n","excerpt":"Run Eclipse Kanto on your edge device.\n","ref":"/kanto/docs/getting-started/install/","tags":"","title":"Install Eclipse Kanto"},{"body":"","categories":"","description":"Customize the remote connectivity and automatic provisioning.\n","excerpt":"Customize the remote connectivity and automatic provisioning.\n","ref":"/kanto/docs/references/connectivity/","tags":"","title":"Remote connectivity configuration"},{"body":"Suite connector enables the remote connectivity to an IoT cloud ecosystem of choice, powered by Eclipse Hono™ (e.g. Eclipse Cloud2Edge and Bosch IoT Suite). It provides the following use cases:\nEnriched remote connection Optimized - to pass the messages via a single underlying connection Secured - to protect the edge identity and data via TLS with basic and certificate-based authentication Maintained - with a reconnect exponential backoff algorithm Synchronized - on a connectivity recovering via a message buffering Application protection - suite connector is the only one component with a remote connectivity i.e. all local applications are protected from exposure to the public network Offline mode - local applications don’t need to care about the status of the remote connection, they can stay fully operable in offline mode How it works The suite connector plays a key role in two communication aspects - local and remote.\nCloud connectivity To initiate its connection, the edge has to be manually or automatically provisioned. The result of this operation is different parameters and identifiers. Currently, suite connector supports MQTT transport as a connection-oriented and requiring less resources in comparison to AMQP. Once established, the connection is used as a channel to pass the edge telemetry and event messages. The IoT cloud can control the edge via commands and responses.\nIn case of a connection interruption, the suite connector will switch to offline mode. The message buffer mechanism will be activated to ensure that there is no data loss. Reconnect exponential backoff algorithm will be started to guarantee that no excessive load will be generated to the IoT cloud. All local applications are not affected and can continue to operate as normal. Once the remote connection is restored, all buffered messages will be sent and the edge will be fully restored to online mode.\nLocal communication Ensuring that local applications are loosely coupled, Eclipse Hono™ MQTT definitions are in use. The event-driven local messages exchange is done via a MQTT message broker - Eclipse Mosquitto™. The suite connector takes the responsibility to forward these messages to the IoT cloud and vice versa.\nThe provisioning information used to establish the remote communication is available locally both on request via a predefined message and on update populated via an announcement. Applications that would like to extend the edge functionality can further use it in Eclipse Hono™ and Eclipse Ditto™ definitions.\nMonitoring of the remote connection status is also enabled locally as well, along with details like the last known state of the connection, timestamp and a predefined connect/disconnect reason.\n","categories":"","description":"Empower the edge device with a remote connectivity.\n","excerpt":"Empower the edge device with a remote connectivity.\n","ref":"/kanto/docs/concepts/suite-connector/","tags":"","title":"Suite connector"},{"body":"Properties To control all aspects of the suite connector behavior.\nProperty Type Default Description provisioningFile string ​ provisioning.json Path to the provisioning file, if Bosch IoT Device Management is in use Remote connectivity address string mqtts://mqtt.bosch-iot-hub.com:8883 Address of the MQTT endpoint that the suite connector will connect for the remote communication, the format is: scheme://host:port deviceId string Device unique identifier authId string Authentication unique identifier that is a part of the credentials tenantId string Tenant unique identifier that the device belongs to password string Password that is a part of the credentials clientId string MQTT client unique identifier policyId string Policy unique identifier of the digital twin Remote connectivity - TLS cacert string iothub.crt PEM encoded CA certificates file cert string PEM encoded certificate file to authenticate to the MQTT endpoint key string PEM encoded unencrypted private key file to authenticate to the MQTT endpoint deviceIdPattern string Pattern to generate the device identifier, {{subject-dn}} and {{subject-cn}} placeholders can be part of it Remote connectivity - TLS over TPM tpmDevice string Path to the device file or the unix socket to access the TPM 2.0 tpmHandle int TPM 2.0 storage root key handle, the type is unsigned 64-bit integer tpmKeyPub string File path to the public part of the TPM 2.0 key tpmKey string File path to the private part of the TPM 2.0 key Local connectivity localAddress string tcp://localhost:1883 Address of the MQTT server/broker that the suite connector will connect for the local communication, the format is: scheme://host:port localUsername string Username that is a part of the credentials localPassword string Password that is a part of the credentials Local connectivity - TLS localCACert string PEM encoded CA certificates file localCert string PEM encoded certificate file to authenticate to the MQTT server/broker localKey string PEM encoded unencrypted private key file to authenticate to the MQTT server/broker Logging logFile string log/suite-connector.log Path to the file where log messages are written logLevel string INFO All log messages at this or higher level will be logged, the log levels in descending order are: ERROR, WARN, INFO, DEBUG and TRACE logFileCount int 5 Log file maximum rotations count logFileMaxAge int 28 Log file rotations maximum age in days, use 0 to not remove old log files logFileSize int 2 Log file size in MB before it gets rotated Example The minimal required configuration to connect the publicly available Eclipse Hono sandbox.\n{ \"address\":\"hono.eclipseprojects.io:1883\", \"cacert\": \"/etc/suite-connector/iothub.crt\", \"tenantId\": \"org.eclipse.kanto\", \"deviceId\": \"org.eclipse.kanto:exampleDevice\", \"authId\": \"org.eclipse.kanto_example\", \"password\": \"secret\", \"logFile\": \"/var/log/suite-connector/suite-connector.log\" } Template The configuration can be further adjusted according to the use case. The following template illustrates all possible properties with their default values.\nWarning Be aware that some combinations may be incompatible { \"provisioningFile\": \"provisioning.json\", \"address\": \"mqtts://mqtt.bosch-iot-hub.com:8883\", \"deviceId\": \"\", \"authId\": \"\", \"tenantId\": \"\", \"password\": \"\", \"clientId\": \"\", \"policyId\": \"\", \"cacert\": \"iothub.crt\", \"cert\": \"\", \"key\": \"\", \"deviceIdPattern\": \"\", \"tpmDevice\": \"\", \"tpmHandle\": 0, \"tpmKeyPub\": \"\", \"tpmKey\": \"\", \"localAddress\": \"tcp://localhost:1883\", \"localUsername\": \"\", \"localPassword\": \"\", \"logFile\": \"log/suite-connector.log\", \"logLevel\": \"INFO\", \"logFileCount\": 5, \"logFileMaxAge\": 28, \"logFileSize\": 2 } ","categories":"","description":"Customize the remote connectivity.\n","excerpt":"Customize the remote connectivity.\n","ref":"/kanto/docs/references/connectivity/suite-connector-config/","tags":"","title":"Suite connector configuration"},{"body":"Following the steps below you will install ahello Debian package via a publicly available Eclipse Hono sandbox using Eclipse Kanto. A couple of simple Eclipse Hono northbound business applications written in Python are provided to explore the capabilities for remotely installing and monitoring. On the edge side, a basic install_hello.sh script will be downloaded and executed.\nBefore you begin To ensure that your edge device is capable to execute the steps in this guide, you need:\nDebian-based linux distribution and the apt command line tool\nIf you don’t have an installed and running Eclipse Kanto, follow Install Eclipse Kanto\nIf you don’t have a connected Eclipse Kanto to Eclipse Hono sandbox, follow Explore via Eclipse Hono\nThe software update application\nNavigate to the quickstart folder where the resources from the Explore via Eclipse Hono guide are located and execute the following script:\nwget https://github.com/eclipse-kanto/kanto/raw/main/quickstart/hono_commands_su.py Executing hello in the terminal will return that the command is not found\nInstall Debian package To explore the software management, we will use two Python scripts to install and monitor the hello Debian package. The location where the Python applications will run does not have to be your edge device as they communicate remotely with Eclipse Hono only.\nFirst, start the monitoring application that requires the configured Eclipse Hono tenant (-t) and will print all received events triggered by the device:\npython3 hono_events.py -t demo In another terminal, we are ready to spin up a hello Debian package at the edge via executing the second application that requires the Eclipse Hono tenant (-t) and the device identifier (-d):\npython3 hono_commands_su.py -t demo -d demo:device Verify You can check out that the new package is installed on your edge device via executing:\nhello The command now displays: Hello, world!\nClean up The installed hello Debian package can be removed via executing:\nsudo apt remove hello ","categories":"","description":"Install a Debian package on your edge device.\n","excerpt":"Install a Debian package on your edge device.\n","ref":"/kanto/docs/how-to-guides/update-software/","tags":"","title":"Update software"},{"body":"Properties To control all aspects of the container instance behavior.\nProperty Type Default Description container_name string \u003ccontainer_id\u003e User-defined name for the container, if omitted the internally auto-generated container ID will be set Image name string Fully qualified image reference, that follows the OCI Image Specification, the format is: host[:port]/[namespace/]name:tag Image - decryption keys string[] Private keys (GPG private key ring, JWE or PKCS7) used for decrypting the container’s image, the format is: filepath_private_key[:password] recipients string[] Recipients (only for PKCS7 and must be an x509) used for decrypting the container’s image, the format is: pkcs7:filepath_x509_certificate Networking domain_name string \u003ccontainer_name\u003e-domain Domain name inside the container, if omitted the container_name with suffix -domain will be set host_name string \u003ccontainer_name\u003e-host Host name for the container, if omitted the container_name with suffix -host will be set network_mode string bridge The container’s networking capabilities type based on the desired communication mode, the possible options are: bridge or host extra_hosts string[] Extra host name to IP address mappings added to the container network configuration, the format is: hostname:ip Networking - port mappings proto string tcp Protocol used for the port mapping from the container to the host, the possible options are: tcp and udp container_port int Port number on the container that is mapped to the host port host_ip string 0.0.0.0 Host IP address host_port int Beginning of the host ports range host_port_end int \u003chost_port\u003e Ending of the host ports range Host resources - devices path_on_host string Path to the device on the host path_in_container string Path to the device in the container cgroup_permissions string rwm Cgroup permissions for the device access, possible options are: r(read), w(write), m(mknod) and all combinations are possible privileged bool false Grant root capabilities to all devices on the host system Host resources - mount points source string Path to the file or directory on the host that is referred from within the container destination string Path to the file or directory that is mounted inside the container propagation_mode string rprivate Bind propagation for the mount, supported are: rprivate, private, rshared, shared, rslave or slave Process env string[] Environment variables that are set into the container cmd string[] Command with arguments that is executed upon the container’s start Resource management memory string Hard memory limitation of the container as a number with a unit suffix of B, K, M and G, the minimum allowed value is 3M memory_reservation string Soft memory limitation of the container as a number with a unit suffix of B, K, M and G, if memory is specified, the memory_reservation must be smaller than it memory_swap string Total amount of memory and swap that the container can use as a number with a unit suffix of B, K, M and G, use -1 to allow the container to use unlimited swap Lifecycle type string unless-stopped The container’s restart policy, the supported types are: always, no, on-failure and unless-stopped maximum_retry_count int Maximum number of retries that are made to restart the container on exit with fail, if the type is on-failure retry_timeout int Timeout period in seconds for each retry that is made to restart the container on exit with fail, if the type is on-failure Logging type string json-file Type in which the logs are produced, the possible options are: json-file or none max_files int 2 Maximum log files before getting rotated max_size string 100M Maximum log file size before getting rotated as a number with a unit suffix of B, K, M and G root_dir string \u003cmeta_path\u003e/containers/\u003ccontainer_id\u003e Root directory where the container’s log messages are stored mode string blocking Messaging delivery mode from the container to the log driver, the supported modes are: blocking and non-blocking max_buffer_size string 1M Maximum size of the buffered container’s log messages in a non-blocking mode as a number with a unit suffix of B, K, M and G Example The minimal required configuration to spin up an InfluxDB container instance.\n{ \"image\": { \"name\": \"docker.io/library/influxdb:1.8.4\" } } Template The configuration can be further adjusted according to the use case. The following template illustrates all possible properties with their default values.\nWarning Be aware that some combinations may require property removal { \"container_name\": \"\", \"image\": { \"name\": \"\", \"decrypt_config\": { \"keys\": [], \"recipients\": [] } }, \"domain_name\": \"\", \"host_name\": \"\", \"mount_points\": [ { \"destination\": \"\", \"source\": \"\", \"propagation_mode\": \"rprivate\" } ], \"config\": { \"env\": [], \"cmd\": [] }, \"host_config\": { \"devices\": [ { \"path_on_host\": \"\", \"path_in_container\": \"\", \"cgroup_permissions\": \"rwm\" } ], \"network_mode\": \"bridge\", \"privileged\": false, \"extra_hosts\": [], \"port_mappings\": [ { \"proto\": \"tcp\", \"container_port\": 0, \"host_ip\": \"0.0.0.0\", \"host_port\": 0, \"host_port_end\": 0 } ], \"resources\": { \"memory\": \"\", \"memory_reservation\": \"\", \"memory_swap\": \"\" }, \"restart_policy\": { \"type\": \"unless-stopped\", \"maximum_retry_count\": 0, \"retry_timeout\": 0 }, \"log_config\": { \"driver_config\": { \"type\": \"json-file\", \"max_files\": 2, \"max_size\": \"100M\", \"root_dir\": \"\" }, \"mode_config\": { \"mode\": \"blocking\", \"max_buffer_size\": \"1M\" } } } } ","categories":"","description":"Customize the deployment of a container instance.\n","excerpt":"Customize the deployment of a container instance.\n","ref":"/kanto/docs/references/containers/container-config/","tags":"","title":"Container configuration"},{"body":"Container management enables a lightweight standard runtime which is capable to run containerized applications with all advantages of the technology: isolation, portability and efficiency. The deployment and management are available both locally and remotely via an IoT cloud ecosystem of choice. The following use cases are provided:\nStandardized approach - with OCI (Open Container Initiative) compliant container images and runtime Lightweight runtime - with a default integration of containerd and a possibility for another container technology of choice like podman, LXC and more Isolation - with a default isolation from other containerized applications and the host system Portability - with an option to run one and the same containerized application on different platforms Pluggable architecture - with extension points on different levels How it works A container image packs the application executable along with all its needed dependencies into a single artifact that can be built by a tooling of choice. The built image is made available for usage by being pushed to a container image registry where the runtime can refer it to.\nTo create a new container instance, the container management uses such an image reference and a configuration for it to produce a fully functional container. The container lifecycle (start, update, stop, remove) and environment (memory constraints, restart policy, etc.) are also handled by the runtime. The container management continuously ensures the applications availability via state awareness and restart policies, provides monitoring via flexible logging and fine-grained resources management. All of that is achieved on top of an underlying runtime of choice (containerd by default) that takes care of the low-level isolation mechanisms.\n","categories":"","description":"Empower the edge device for containerized applications.\n","excerpt":"Empower the edge device for containerized applications.\n","ref":"/kanto/docs/concepts/container-management/","tags":"","title":"Container management"},{"body":"","categories":"","description":"Customize the deployment and management of containers.\n","excerpt":"Customize the deployment and management of containers.\n","ref":"/kanto/docs/references/containers/","tags":"","title":"Container management configuration"},{"body":"Following the steps below you will connect your first device to a publicly available Eclipse Hono sandbox using Eclipse Kanto. A couple of simple Eclipse Hono northbound business applications written in Python are provided to explore the capabilities for remotely managing and monitoring your edge device.\nBefore you begin The location where the Python applications and utility shell scripts will run does not have to be your edge device as they communicate remotely with Eclipse Hono only. To run them, you need:\nPython 3 and pip3\nThe quickstart applications and provisioning scripts\nYou can execute the script below to download them automatically:\nmkdir quickstart \u0026\u0026 cd quickstart \u0026\u0026 \\ wget https://github.com/eclipse-kanto/kanto/raw/main/quickstart/hono_commands.py \u0026\u0026 \\ wget https://github.com/eclipse-kanto/kanto/raw/main/quickstart/hono_events.py \u0026\u0026 \\ wget https://github.com/eclipse-kanto/kanto/raw/main/quickstart/requirements.txt \u0026\u0026 \\ wget https://github.com/eclipse-kanto/kanto/raw/main/quickstart/hono_provisioning.sh Required Python dependencies to run the scripts\nYou can install them by using the downloaded requirements.txt file via executing:\npip3 install -r requirements.txt Provision the Eclipse Hono tenant and device In order to be able to connect your device to Eclipse Hono, you need to have a dedicated tenant and a device instance provisioned for it. Fill in the required empty environmental variables definitions in the hono_provisioning.sh, e.g.: Tip It’s nice to choose relatively unique and personalized values to avoid collisions in the public Eclipse Hono sandbox # The Hono tenant to be created export TENANT=demo # The identifier of the device on the tenant # Note! It's important for the ID to follow the convention namespace:name (e.g. demo:device) export DEVICE_ID=demo:device # The authentication identifier of the device export AUTH_ID=demo_device # A password for the device to authenticate with export PWD=secret Run the provisioning script and you will have your Eclipse Hono tenant and device ready to be connected:\n./hono_provisioning.sh Configure Eclipse Kanto Eclipse Kanto uses the /etc/suite-connector/config.json to acquire all the remote communication, identification and authentication data to establish the remote connection. Update it with the following:\n{ \"cacert\": \"/etc/suite-connector/iothub.crt\", \"provisioningFile\": \"/etc/suite-connector/provisioning.json\", \"logFile\": \"/var/log/suite-connector/suite-connector.log\", \"address\":\"hono.eclipseprojects.io:1883\", \"tenantId\":\"demo\", \"deviceId\":\"demo:device\", \"authId\":\"demo_device\", \"password\":\"secret\" } Restart the Suite Connector service for the changes to take effect:\nsudo systemctl restart suite-connector.service Verify To explore remote containerized applications management, we will use the two Python scripts to run, monitor and remove a simple InfluxDB container using its public container image available at Docker Hub.\nFirst, start the monitoring application that requires the configured Eclipse Hono tenant (-t) and will print all received events triggered by the device:\npython3 hono_events.py -t demo In another terminal, we are ready to spin up an InfluxDB container instance at the edge via executing the second application that requires the command to execute (run), the Eclipse Hono tenant (-t), device identifier (-d) and the full container image reference to use (--img):\npython3 hono_commands.py run -t demo -d demo:device --img docker.io/library/influxdb:1.8.4 After the script exits with success, you can check out the new container running on your edge device via executing:\nsudo kanto-cm list Looking at the terminal where the monitoring application is running, you will be able to see all the events triggered by the operation.\nTo remove the newly created container, execute the same application script only this time with the rm command and the identifier of the container to remove (--id), e.g.:\npython3 hono_commands.py rm -t demo -d demo:device --id e6f7fbea-0e95-433c-acc7-16ef21b9c033 ","categories":"","description":"Connect and start managing your edge device via Eclipse Hono.\n","excerpt":"Connect and start managing your edge device via Eclipse Hono.\n","ref":"/kanto/docs/getting-started/hono/","tags":"","title":"Explore via Eclipse Hono"},{"body":"","categories":"","description":"Explore different ways to connect and manage your edge device remotely using Eclipse Kanto.\n","excerpt":"Explore different ways to connect and manage your edge device remotely …","ref":"/kanto/docs/getting-started/","tags":"","title":"Getting started"},{"body":"Properties To control all aspects of the container manager behavior.\nProperty Type Default Description home_dir string /var/lib/container-management Home directory for the container manager data exec_root_dir string /var/run/container-management Root directory for the container manager’s executable artifacts container_client_sid string container-management.service.local.v1.service-containerd-client Unique identifier that is used for an interaction with the runtime network_manager_sid string container-management.service.local.v1.service-libnetwork-manager Unique identifier that is used for networking default_ctrs_stop_timeout int 30 Timeout in seconds for a container to stop gracefully, otherwise its root process will be force stopped Runtime default_ns string kanto-cm Namespace that is used by the runtime for isolation address_path string /run/containerd/containerd.sock Path to the runtime’s communication endpoint home_dir string /var/lib/container-management Home directory for the runtime data exec_root_dir string /var/run/container-management Root directory for the runtime’s executable artifacts image_dec_keys string[] Private keys (GPG private key ring, JWE or PKCS7) used for decrypting container images, the format is: filepath_private_key[:password] image_dec_recipients string[] Recipients (only for PKCS7 and must be an x509) used for decrypting container images, the format is: pkcs7:filepath_x509_certificate runc_runtime string io.containerd.runc.v2 Runc communication mode, the possible values are: io.containerd.runtime.v1.linux, io.containerd.runc.v1 and io.containerd.runc.v2 Registry access - secure user_id string User unique identifier to authenticate to the image registry password string Password to authenticate to the image registry root_ca string PEM encoded CA certificates file client_cert string PEM encoded certificate file to authenticate to the image registry client_key string PEM encoded unencrypted private key file to authenticate to the image registry Registry access - insecure insecure_registries string[] localhost Image registries that do not use valid certificates or do not require a HTTPS connection, the format is: host[:port] Networking home_dir string /var/lib/container-management Home directory for the network manager data exec_root_dir string /var/run/container-management Root directory for the network manager’s executable artifacts Networking - bridge name string kanto-cm0 Bridge name ip4 string Bridge IPv4 address fcidr4 string IPv4 address range for the bridge, using the standard CIDR notation gwip4 string Bridge gateway IPv4 address enable_ip6 bool false Permit the bridge IPv6 support mtu int 1500 Bridge maximum transmission unit in bytes icc bool true Permit the inter-container communication ip_tables bool true Permit the IP tables rules ip_forward bool true Permit the IP forwarding ip_masq bool true Permit the IP masquerading userland_proxy bool false Forbid the userland proxy for the loopback traffic Local communication protocol string unix Communication protocol used for accessing the gRPC server, the possible values are: tcp, tcp4, tcp6, unix or unixpacket address_path string /run/container-management/container-management.sock Path to the gRPC server’s communication endpoint Digital twin enable bool true Permit the container manager digital twin representation home_dir string /var/lib/container-management Home directory for the digital twin data features string[] ContainerFactory, SoftwareUpdatable Features that will be registered for the container manager digital twin, the possible values are: ContainerFactory and SoftwareUpdatable Digital twin - connectivity broker_url string tcp://localhost:1883 Address of the MQTT server/broker that the container manager will connect for the local communication, the format is: scheme://host:port keep_alive int 20000 Keep alive duration in milliseconds for the MQTT requests disconnect_timeout int 250 Disconnect timeout in milliseconds for the MQTT server/broker client_username string Username that is a part of the credentials client_password string Password that is a part of the credentials connect_timeout int 30000 Connect timeout in milliseconds for the MQTT server/broker acknowledge_timeout int 15000 Acknowledge timeout in milliseconds for the MQTT requests subscribe_timeout int 15000 Subscribe timeout in milliseconds for the MQTT requests unsubscribe_timeout int 5000 Unsubscribe timeout in milliseconds for the MQTT requests Logging log_file string log/container-management.log Path to the file where the container manager’s log messages are written log_level string INFO All log messages at this or a higher level will be logged, the log levels in descending order are: ERROR, WARN, INFO, DEBUG and TRACE log_file_count int 5 Log file maximum rotations count log_file_max_age int 28 Log file rotations maximum age in days, use 0 to not remove old log files log_file_size int 2 Log file size in MB before it gets rotated syslog bool false Route logs to the local syslog Example The minimal required configuration that sets a timeout period of 5 seconds for the managed containers to stop gracefully.\n{ \"manager\": { \"default_ctrs_stop_timeout\": 5 }, \"log\": { \"log_file\": \"/var/log/container-management/container-management.log\" } } Template The configuration can be further adjusted according to the use case. The following template illustrates all possible properties with their default values.\nWarning Be aware that in the registry configuration the host (used as a key) has to be set instead of the default empty string, the format is: host[:port] { \"manager\": { \"home_dir\": \"/var/lib/container-management\", \"exec_root_dir\": \"/var/run/container-management\", \"container_client_sid\": \"container-management.service.local.v1.service-containerd-client\", \"network_manager_sid\": \"container-management.service.local.v1.service-libnetwork-manager\", \"default_ctrs_stop_timeout\": 30 }, \"containers\": { \"default_ns\": \"kanto-cm\", \"address_path\": \"/run/containerd/containerd.sock\", \"exec_root_dir\": \"/var/run/container-management\", \"home_dir\": \"/var/lib/container-management\", \"image_dec_keys\": [], \"image_dec_recipients\": [], \"runc_runtime\": \"io.containerd.runc.v2\", \"registry_configurations\": { \"\": { \"credentials\": { \"user_id\": \"\", \"password\": \"\" }, \"transport\": { \"root_ca\": \"\", \"client_cert\": \"\", \"client_key\": \"\" } } }, \"insecure_registries\": [ \"localhost\" ] }, \"network\": { \"home_dir\": \"/var/lib/container-management\", \"exec_root_dir\": \"/var/run/container-management\", \"default_bridge\": { \"name\": \"kanto-cm0\", \"ip4\": \"\", \"fcidr4\": \"\", \"enable_ip6\": false, \"mtu\": 1500, \"icc\": true, \"ip_tables\": true, \"ip_forward\": true, \"ip_masq\": true, \"userland_proxy\": false } }, \"grpc_server\": { \"protocol\": \"unix\", \"address_path\": \"/run/container-management/container-management.sock\" }, \"things\": { \"enable\": true, \"home_dir\": \"/var/lib/container-management\", \"features\": [ \"ContainerFactory\", \"SoftwareUpdatable\" ], \"connection\": { \"broker_url\": \"tcp://localhost:1883\", \"keep_alive\": 20000, \"disconnect_timeout\": 250, \"client_username\": \"\", \"client_password\": \"\", \"connect_timeout\": 30000, \"acknowledge_timeout\": 15000, \"subscribe_timeout\": 15000, \"unsubscribe_timeout\": 5000 } }, \"log\": { \"log_file\": \"log/container-management.log\", \"log_level\": \"INFO\", \"log_file_count\": 5, \"log_file_size\": 2, \"log_file_max_age\": 28, \"syslog\": false } } ","categories":"","description":"Customize the container manager components.\n","excerpt":"Customize the container manager components.\n","ref":"/kanto/docs/references/containers/container-manager-config/","tags":"","title":"Manager configuration"},{"body":"Properties To control all aspects of the suite bootstrapping behavior.\nProperty Type Default Description preBootstrapScript string Path to the script/command with optional space-separated arguments that is executed before a bootstrapping request, optionally producing a preBootstrapFile preBootstrapFile string Path to the file used as a bootstrapping request data postBootstrapScript string Path to the script/command with optional space-separated arguments that is executed after a bootstrapping response, optionally consuming a postBootstrapFile postBootstrapFile string Path to the file used for a bootstrapping response data bootstrapProvisioningFile string Path to the file that stores the provisioning information from a bootstrapping response maxChunkSize int 46080 Maximum chunk size of the request data in bytes provisioningFile string provisioning.json Path to the provisioning file, if Bosch IoT Device Management is in use Remote connectivity address string mqtts://mqtt.bosch-iot-hub.com:8883 Address of the MQTT endpoint that the suite bootstrapping will connect for the remote communication, the format is: scheme://host:port deviceId string Device unique identifier authId string Authentication unique identifier that is a part of the credentials tenantId string Tenant unique identifier that the device belongs to password string Password that is a part of the credentials clientId string MQTT client unique identifier policyId string Policy unique identifier of the digital twin Remote connectivity - TLS caCert string iothub.crt PEM encoded CA certificates file cert string PEM encoded certificate file to authenticate to the MQTT endpoint key string PEM encoded unencrypted private key file to authenticate to the MQTT endpoint deviceIdPattern string Pattern to generate the device identifier, {{subject-dn}} and {{subject-cn}} placeholders can be part of it Remote connectivity - TLS over TPM tpmDevice string Path to the device file or the unix socket to access the TPM 2.0 tpmHandle int TPM 2.0 storage root key handle, the type is unsigned 64-bit integer tpmKeyPub string File path to the public part of the TPM 2.0 key tpmKey string File path to the private part of the TPM 2.0 key Logging logFile string log/suite-bootstrapping.log Path to the file where log messages are written logLevel string INFO All log messages at this or higher level will be logged, the log levels in descending order are: ERROR, WARN, INFO, DEBUG and TRACE logFileCount int 5 Log file maximum rotations count logFileMaxAge int 28 Log file rotations maximum age in days, use 0 to not remove old log files logFileSize int 2 Log file size in MB before it gets rotated Example\nThe minimal required configuration to connect the publicly available Eclipse Hono sandbox and request automatic provisioning.\n{ \"address\":\"hono.eclipseprojects.io:1883\", \"tenantId\": \"org.eclipse.kanto\", \"deviceId\": \"org.eclipse.kanto:exampleDevice\", \"authId\": \"org.eclipse.kanto_example\", \"password\": \"secret\", \"logFile\": \"/var/log/suite-bootstrapping/suite-bootstrapping.log\" } Template The configuration can be further adjusted according to the use case. The following template illustrates all possible properties with their default values.\nWarning Be aware that some combinations may be incompatible { \"preBootstrapScript\": \"\", \"preBootstrapFile\": \"\", \"postBootstrapScript\": \"\", \"postBootstrapFile\": \"\", \"bootstrapProvisioningFile\": \"\", \"maxChunkSize\": 46080, \"provisioningFile\": \"provisioning.json\", \"address\": \"mqtts://mqtt.bosch-iot-hub.com:8883\", \"deviceId\": \"\", \"authId\": \"\", \"tenantId\": \"\", \"password\": \"\", \"clientId\": \"\", \"policyId\": \"\", \"caCert\": \"iothub.crt\", \"cert\": \"\", \"key\": \"\", \"deviceIdPattern\": \"\", \"tpmDevice\": \"\", \"tpmHandle\": 0, \"tpmKeyPub\": \"\", \"tpmKey\": \"\", \"logFile\": \"log/suite-bootstrapping.log\", \"logLevel\": \"INFO\", \"logFileCount\": 5, \"logFileMaxAge\": 28, \"logFileSize\": 2 } ","categories":"","description":"Customize the automatic provisioning.\n","excerpt":"Customize the automatic provisioning.\n","ref":"/kanto/docs/references/connectivity/suite-bootstrapping-config/","tags":"","title":"Suite bootstrapping configuration"},{"body":"Following the steps below you will upload an example log file to your HTTP file server via a publicly available Eclipse Hono sandbox using Eclipse Kanto. A simple Eclipse Hono northbound business application written in Python is provided to explore the capabilities for remotely uploading and monitoring.\nBefore you begin To ensure that all steps in this guide can be executed, you need:\nservefile installed\nThis is a small Python HTTP server used in the example to serve the uploads. It does not have to be running on your edge device but it has to be accessible from there. You can install it by executing:\npip3 install servefile If you don’t have an installed and running Eclipse Kanto on your edge device, follow Install Eclipse Kanto\nIf you don’t have a connected Eclipse Kanto to Eclipse Hono sandbox, follow Explore via Eclipse Hono\nThe file upload application\nNavigate to the quickstart folder where the resources from the Explore via Eclipse Hono guide are located and execute the following script:\nwget https://github.com/eclipse-kanto/kanto/raw/main/quickstart/hono_commands_fu.py Upload log file By default, all files in /var/tmp/file-upload/ directory can be uploaded. For example, grab the suite connector log file and place it in the directory via executing:\nmkdir -p /var/tmp/file-upload/ \u0026\u0026 sudo cp /var/log/suite-connector/suite-connector.log /var/tmp/file-upload/ Choose a directory where the log file will be uploaded, open a new terminal there and run servefile:\nservefile -u . To explore the file upload, we will use a Python script to request and monitor the operation. The location where the Python application will run does not have to be your edge device as it communicates remotely with Eclipse Hono only.\nNow we are ready to request the log file upload from the edge via executing the application that requires the Eclipse Hono tenant (-t) and the device identifier (-d):\npython3 hono_commands_fu.py -t demo -d demo:device Verify You can check out that the log file is on your HTTP file server listing the content of servefile working directory.\nClean up Stop servefile and clean up its working directory.\n","categories":"","description":"Upload a log file from your edge device.\n","excerpt":"Upload a log file from your edge device.\n","ref":"/kanto/docs/how-to-guides/upload-files/","tags":"","title":"Upload files"},{"body":"","categories":"","description":"Explore key essentials of Eclipse Kanto.\n","excerpt":"Explore key essentials of Eclipse Kanto.\n","ref":"/kanto/docs/concepts/","tags":"","title":"Concepts"},{"body":"Bosch IoT Device Managementenables remote data, management and configuration of devices and fleets of devices in a unified and flexible manner. Eclipse Kanto is Bosch IoT Device Management integrated out-of-the-box.\nBefore you begin To ensure you have prepared the backend where your device will be connected you will need to perform the following\nCreate a free Bosch IoT Device Management subscription if you do not already have one Provision a gateway device from scratch with automatic provisioning of edge devices enabled so that you are able to explore all capabilities provided by Eclipse Kanto Configure Eclipse Kanto Eclipse Kanto uses the generated provisioning.json to acquire all the remote communication, identification and authentication data to establish the remote connection. Once you have it available on the device in /etc/suite-connector/provisioning.json, Eclipse Kanto will connect your device automatically.\nVerify If the connection has been established successfully, you should be able to see two Things with a green plugged-in icon on the right-hand side\n\u003cyour-namespace\u003e:\u003cgateway-name\u003e - the gateway you have provisioned with Features, e.g. ConnectionStatus Autouploadable SoftwareUpdatable \u003cyour-namespace\u003e:\u003cgateway-name\u003e:edge:containers - a virtual one that provides the edge container management Features, e.g. ConnectionStatus ContainerFactory SoftwareUpdatable What’s next Learn how to manage your device via Bosch IoT Device Management ","categories":"","description":"Connect and start managing your edge device via Bosch IoT Device Management.\n","excerpt":"Connect and start managing your edge device via Bosch IoT Device …","ref":"/kanto/docs/getting-started/dmp/","tags":"","title":"Explore via Bosch IoT Device Management"},{"body":"Software update enables the deployment and management of various software artifacts, both locally and remotely via an IoT cloud ecosystem of choice. It provides the following use cases:\nRobust download - with a retry and resume mechanism when the network connection is interrupted Artifact validation - with an integrity validation of every downloaded artifact Universal installation - with customizable install scripts to handle any kind of software Operation monitoring - with a status reporting of the download and install operations How it works When the install operation is received at the edge, the download process is initiated. Retrieving the artifacts will continue until they are stored at the edge or their size threshold is reached. If successful, the artifacts are validated for integrity and further processed by the configured script. It is responsible to apply the new software and finish the operation. A status report is announced on each step of the process enabling its transparent monitoring.\nOn start up, if there have been any ongoing operations, they will be automatically resumed as the operation state is persistently stored.\nWhat’s next How to update software\n","categories":"","description":"Empower the edge device to handle diverse software updates.\n","excerpt":"Empower the edge device to handle diverse software updates.\n","ref":"/kanto/docs/concepts/software-update/","tags":"","title":"Software update"},{"body":"Properties To control all aspects of the software update behavior.\nProperty Type Default Description featureId string SoftwareUpdatable Feature unique identifier in the scope of the edge digital twin moduleType string software Type of the software that is managed by this feature artifactType string archive Type of the artifact that is to be processed: archive or plain install string[] Absolute path to the install script/command and an optional sequence of additional flags/parameters storageLocation string ./ Path to the storage directory where the working files are stored Local connectivity broker string tcp://localhost:1883 Address of the MQTT server/broker that the software update will connect for the local communication, the format is: scheme://host:port username string Username that is a part of the credentials password string Password that is a part of the credentials Logging logFile string log/software-update.log Path to the file where log messages are written logLevel string INFO All log messages at this or higher level will be logged, the log levels in descending order are: ERROR, WARN, INFO, DEBUG and TRACE logFileCount int 5 Log file maximum rotations count logFileMaxAge int 28 Log file rotations maximum age in days, use 0 to not remove old log files logFileSize int 2 Log file size in MB before it gets rotated Example The minimal required configuration that sets the software type to firmware.\n{ \"moduleType\": \"firmware\", \"storageLocation\": \"/var/lib/software-update\", \"logFile\": \"/var/log/software-update/software-update.log\" } Template The configuration can be further adjusted according to the use case. The following template illustrates all possible properties with their default values.\n{ \"featureId\": \"SoftwareUpdatable\", \"moduleType\": \"software\", \"artifactType\": \"archive\", \"install\": [], \"storageLocation\": \"./\", \"broker\": \"tcp://localhost:1883\", \"username\": \"\", \"password\": \"\", \"logFile\": \"log/software-update.log\", \"logLevel\": \"INFO\", \"logFileCount\": 5, \"logFileMaxAge\": 28, \"logFileSize\": 2 } ","categories":"","description":"Customize the deployment and management of software artifacts.\n","excerpt":"Customize the deployment and management of software artifacts.\n","ref":"/kanto/docs/references/software-update-config/","tags":"","title":"Software update configuration"},{"body":"File upload enables sending of files to a backend storage of choice. It can be used both locally and remotely via a desired IoT cloud ecosystem. The following use cases are provided:\nStorage diversity - with ready to use integrations with Azure Blob Storage, Amazon S3 and standard HTTP upload Automatic uploads - with periodically triggered uploads at a specified interval in a given time frame Data integrity - with an option to calculate and send the integrity check required information Operation monitoring - with a status reporting of the upload operation How it works It’s not always possible to inline all the data into exchanged messages. For example, large log files or large diagnostic files cannot be sent as a telemetry message. In such scenarios, file upload can assist enabling massive amount of data to be stored to the backend storage.\nThere are different triggers which can initiate the upload operation: periodic or explicit. Once initiated, the request will be sent to the IoT cloud for confirmation or cancellation transferred back to the edge. If starting is confirmed, the files to upload will be selected according to the specified configuration, their integrity check information can be calculated and the transfer of the binary content will begin. A status report is announced on each step of the upload process enabling its transparent monitoring.\nWhat’s next How to upload files\n","categories":"","description":"Empower the edge device to upload files to various storage providers.\n","excerpt":"Empower the edge device to upload files to various storage providers.\n","ref":"/kanto/docs/concepts/file-upload/","tags":"","title":"File upload"},{"body":"Properties To control all aspects of the file upload behavior.\nProperty Type Default Description featureId string AutoUploadable Feature unique identifier in the scope of the edge digital twin type string file Type of the files that are uploaded by this feature context string edge Context of the files that are uploaded by this feature, unique in the scope of the type files string Glob pattern to select the files for upload mode string strict Restriction on files that can be dynamically selected for an upload, the supported modes are: strict, lax and scoped singleUpload bool false Forbid triggering of new uploads when there is an upload in progress checksum bool false Send MD5 checksum for uploaded files to ensure data integrity stopTimeout string 30s Time to wait for running uploads to finish as a sequence of decimal numbers, each with optional fraction and a unit suffix, such as: 300ms, 1.5h, 10m30s, etc., time units are: ns, us (or µs), ms, s, m, h delete bool false Delete successfully uploaded files Upload - TLS serverCert string PEM encoded certificate file for secure uploads Auto upload active bool false Activate periodic uploads activeFrom string Time from which periodic uploads should be active, in RFC 3339 format, if omitted (and active flag is set) current time will be used as start of the periodic uploads activeTill string Time till which periodic uploads should be active, in RFC 3339 format, if omitted (and active flag is set) periodic uploads will be active indefinitely period string 10h Upload period as a sequence of decimal numbers, each with optional fraction and a unit suffix, such as: 300ms, 1.5h, 10m30s, etc., time units are: ns, us (or µs), ms, s, m, h Local connectivity broker string tcp://localhost:1883 Address of the MQTT server/broker that the file upload will connect for the local communication, the format is: scheme://host:port username string Username that is a part of the credentials password string Password that is a part of the credentials Local connectivity - TLS caCert string PEM encoded CA certificates file cert string PEM encoded certificate file to authenticate to the MQTT server/broker key string PEM encoded unencrypted private key file to authenticate to the MQTT server/broker Logging logFile string log/file-upload.log Path to the file where log messages are written logLevel string INFO All log messages at this or higher level will be logged, the log levels in descending order are: ERROR, WARN, INFO, DEBUG and TRACE logFileCount int 5 Log file maximum rotations count logFileMaxAge int 28 Log file rotations maximum age in days, use 0 to not remove old log files logFileSize int 2 Log file size in MB before it gets rotated Example The minimal required configuration that sets the file type to log.\n{ \"type\": \"log\", \"files\": \"/var/tmp/file-upload/*.*\", \"logFile\": \"/var/log/file-upload/file-upload.log\" } Template The configuration can be further adjusted according to the use case. The following template illustrates all possible properties with their default values.\n{ \"featureId\": \"AutoUploadable\", \"type\": \"file\", \"context\": \"edge\", \"files\": \"\", \"mode\": \"strict\", \"singleUpload\": false, \"checksum\": false, \"stopTimeout\": \"30s\", \"delete\": false, \"serverCert\": \"\", \"active\": false, \"activeFrom\": \"\", \"activeTill\": \"\", \"period\": \"10h\", \"broker\": \"tcp://localhost:1883\", \"username\": \"\", \"password\": \"\", \"caCert\": \"\", \"cert\": \"\", \"key\": \"\", \"logFile\": \"log/file-upload.log\", \"logLevel\": \"INFO\", \"logFileCount\": 5, \"logFileMaxAge\": 28, \"logFileSize\": 2 } ","categories":"","description":"Customize the files transfer to a backend storage.\n","excerpt":"Customize the files transfer to a backend storage.\n","ref":"/kanto/docs/references/file-upload-config/","tags":"","title":"File upload configuration"},{"body":"","categories":"","description":"Explore the functionalities of Eclipse Kanto.\n","excerpt":"Explore the functionalities of Eclipse Kanto.\n","ref":"/kanto/docs/how-to-guides/","tags":"","title":"How-to guides"},{"body":"","categories":"","description":"Explore customization of Eclipse Kanto.\n","excerpt":"Explore customization of Eclipse Kanto.\n","ref":"/kanto/docs/references/","tags":"","title":"References"},{"body":"Properties To control all aspects of the system metrics behavior.\nProperty Type Default Description frequency string Initial system metrics reporting frequency as a sequence of decimal numbers, each with optional fraction and a unit suffix, such as: 300ms, 1.5h, 10m30s, etc., time units are: ns, us (or µs), ms, s, m, h Local connectivity broker string tcp://localhost:1883 Address of the MQTT server/broker that the system metrics will connect for the local communication, the format is: scheme://host:port username string Username that is a part of the credentials password string Password that is a part of the credentials Logging logFile string log/system-metrics.log Path to the file where log messages are written logLevel string INFO All log messages at this or higher level will be logged, the log levels in descending order are: ERROR, WARN, INFO, DEBUG and TRACE logFileCount int 5 Log file maximum rotations count logFileMaxAge int 28 Log file rotations maximum age in days, use 0 to not remove old log files logFileSize int 2 Log file size in MB before it gets rotated Example The minimal required configuration that enables the auto reporting of system metrics.\n{ \"frequency\": \"60s\", \"logFile\": \"/var/log/system-metrics/system-metrics.log\" } Template The configuration can be further adjusted according to the use case. The following template illustrates all possible properties with their default values.\n{ \"frequency\" : \"\" \"broker\": \"tcp://localhost:1883\", \"username\": \"\", \"password\": \"\", \"logFile\": \"log/system-metrics.log\", \"logLevel\": \"INFO\", \"logFileCount\": 5, \"logFileMaxAge\": 28, \"logFileSize\": 2 } ","categories":"","description":"Customize the reporting of system metrics.\n","excerpt":"Customize the reporting of system metrics.\n","ref":"/kanto/docs/references/system-metrics-config/","tags":"","title":"System metrics configuration"},{"body":"Cloud connectivity Connect devices to the Bosch IoT Suite cloud services, powered by Eclipse Hono™:\nBasic and certificate-based device authentication Auto-registration of edge devices using certificates Device telemetry data and operations handling Configurable connectivity recovery mechanisms Messages-based synchronization on connectivity recovered Digital twins Represent connected edge devices and semantically model their capabilities, powered by Eclipse Ditto™ and Eclipse Vorto™:\nDevice state, data and operations handling via Eclipse Ditto™ digital twins Ready-to-use pre-defined Eclipse Vorto™ semantic models for all Eclipse Kanto features Out-of-the box support for existing and customized device capability modelled via Eclipse Vorto Local communication Develop loosely coupled event-driven applications that exchange messages over Eclipse Mosquitto™ as a local MQTT broker:\nMQTT broker access control via local basic authentication support Мessages forwarding between applications running on the edge device and to the cloud Access and manage connected IoT devices, IoT device data and services in cloud and at the edge via Eclipse Ditto protocol Lightweight container management Pluggable container management optimized for edge use cases to enable a secured, isolated and reliable deployment mechanism and runtime for edge applications:\nLightweight management layer that integrates with a container technology of choice - containerd, podman, Docker, LXC and more Uniform API for containers lifecycle, state, networking, host resources access and usage management Pluggable architecture enabling transparent container management components exchange and customizations on different levels Remote deployment and management of containers via Eclipse Ditto digital twins and Eclipse Vorto models Working with private and public secured container image registries Flexible software updates Deploy and manage various software artifacts at the edge by using open and generic software update model, powered by Eclipse Vorto and Eclipse hawkBit™:\nExtensible and configurable software download and installation flows to enable update of any software Ready-to-use script-based software updates to easily implement specific download and install operations, progress tracking, artifact validation, on start up resume and more Flexible file uploads Upload files like logs, configurations, diagnostics, backups and more using backend storage of choice:\nReady-to-use integrations with Azure Cloud Storage and AWS S3 buckets Configuration for periodic uploads or explicitly trigger file upload from the device and more Flexible deployment Choose and combine configurable building blocks deployable on wide range of edge platforms:\nSpecifically optimized for constrained devices to offer compact footprint and optimal utilization of resources Configurable features to allow additional resources allocation fine tuning Ready-to-use builds for Linux ARM, Linux ARM64, Linux x86_64 Integrated with open hardware platforms like Raspberry Pi ","categories":"","description":"","excerpt":"Cloud connectivity Connect devices to the Bosch IoT Suite cloud …","ref":"/kanto/about/features/","tags":"","title":""},{"body":"We are living in an era of digitization, in which companies are reshaping their operations and innovating their business models by offering next generation connected products and digital services. Machines, consumer goods and vehicles are transforming into complex connected IoT devices with advanced software features, collecting and reacting on user insights and data in real-time in secure and safe way.\nEdge computing is shifting from hardware to software focusing on intelligent devices, edge platforms, edge applications and services. New connected products continuously increase in complexity to benefit AIoT – be it built into the products or empowering the production lines. Building the products of the future such as connected vehicles and in vehicle cross-domain applications, connected appliances, smart buildings and connected manufacturing is becoming more and more complex and companies are losing time and money to build the common technologies by themselves, sometimes even lacking the right skills and expertise.\nWe bring our knowledge and 20+ years of IoT and edge experience in the open source to enable true collaboration, technology co-development and co-innovation! We address the sheer complexity of edge software and hardware via open technology and ecosystem approach ensuring freedom of choice with vendor-neutral, independent jointly-developed software that goes at the heart of manufactured devices.\n","categories":"","description":"","excerpt":"We are living in an era of digitization, in which companies are …","ref":"/kanto/about/motivation/","tags":"","title":""},{"body":"Eclipse Kanto™ is a modular IoT edge software that enables devices for IoT with all essentials like cloud connectivity, digital twins, local communication, container management, and software updates - all configurable and remotely manageable by an IoT cloud ecosystem of choice.\nEclipse Kanto makes it possible to deploy intelligence on the device so companies can get more value from diverse edge assets, process and act on IoT data right on the device and manage devices from the cloud. Device manufacturers can add new revenue streams with connected products and ensure agile development for hardware and software.\nUsing Eclipse Kanto, technology teams take advantage of configurable and reusable building blocks to connect the unconnected or build the edge applications for the next generation connected products and services.\nEclipse Kanto is specifically optimized for complex IoT devices facing limited hardware resources, (near) real-time requirements, diverse device software, heterogeneous data sources and the ability to operate without connection. This makes it a perfect technology for emerging paradigms such as software-defined vehicles, connected machines and connected manufacturing, smart appliances, smart buildings and more.\n","categories":"","description":"","excerpt":"Eclipse Kanto™ is a modular IoT edge software that enables devices for …","ref":"/kanto/about/overview/","tags":"","title":""},{"body":" About Eclipse Kanto motivation | overview | features\nMotivation We are living in an era of digitization, in which companies are reshaping their operations and innovating their business models by offering next generation connected products and digital services. Machines, consumer goods and vehicles are transforming into complex connected IoT devices with advanced software features, collecting and reacting on user insights and data in real-time in secure and safe way.\nEdge computing is shifting from hardware to software focusing on intelligent devices, edge platforms, edge applications and services. New connected products continuously increase in complexity to benefit AIoT – be it built into the products or empowering the production lines. Building the products of the future such as connected vehicles and in vehicle cross-domain applications, connected appliances, smart buildings and connected manufacturing is becoming more and more complex and companies are losing time and money to build the common technologies by themselves, sometimes even lacking the right skills and expertise.\nWe bring our knowledge and 20+ years of IoT and edge experience in the open source to enable true collaboration, technology co-development and co-innovation! We address the sheer complexity of edge software and hardware via open technology and ecosystem approach ensuring freedom of choice with vendor-neutral, independent jointly-developed software that goes at the heart of manufactured devices.\nOverview Eclipse Kanto™ is a modular IoT edge software that enables devices for IoT with all essentials like cloud connectivity, digital twins, local communication, container management, and software updates - all configurable and remotely manageable by an IoT cloud ecosystem of choice.\nEclipse Kanto makes it possible to deploy intelligence on the device so companies can get more value from diverse edge assets, process and act on IoT data right on the device and manage devices from the cloud. Device manufacturers can add new revenue streams with connected products and ensure agile development for hardware and software.\nUsing Eclipse Kanto, technology teams take advantage of configurable and reusable building blocks to connect the unconnected or build the edge applications for the next generation connected products and services.\nEclipse Kanto is specifically optimized for complex IoT devices facing limited hardware resources, (near) real-time requirements, diverse device software, heterogeneous data sources and the ability to operate without connection. This makes it a perfect technology for emerging paradigms such as software-defined vehicles, connected machines and connected manufacturing, smart appliances, smart buildings and more.\nFeatures Cloud connectivity Connect devices to the Bosch IoT Suite cloud services, powered by Eclipse Hono™:\nBasic and certificate-based device authentication Auto-registration of edge devices using certificates Device telemetry data and operations handling Configurable connectivity recovery mechanisms Messages-based synchronization on connectivity recovered Digital twins Represent connected edge devices and semantically model their capabilities, powered by Eclipse Ditto™ and Eclipse Vorto™:\nDevice state, data and operations handling via Eclipse Ditto™ digital twins Ready-to-use pre-defined Eclipse Vorto™ semantic models for all Eclipse Kanto features Out-of-the box support for existing and customized device capability modelled via Eclipse Vorto Local communication Develop loosely coupled event-driven applications that exchange messages over Eclipse Mosquitto™ as a local MQTT broker:\nMQTT broker access control via local basic authentication support Мessages forwarding between applications running on the edge device and to the cloud Access and manage connected IoT devices, IoT device data and services in cloud and at the edge via Eclipse Ditto protocol Lightweight container management Pluggable container management optimized for edge use cases to enable a secured, isolated and reliable deployment mechanism and runtime for edge applications:\nLightweight management layer that integrates with a container technology of choice - containerd, podman, Docker, LXC and more Uniform API for containers lifecycle, state, networking, host resources access and usage management Pluggable architecture enabling transparent container management components exchange and customizations on different levels Remote deployment and management of containers via Eclipse Ditto digital twins and Eclipse Vorto models Working with private and public secured container image registries Flexible software updates Deploy and manage various software artifacts at the edge by using open and generic software update model, powered by Eclipse Vorto and Eclipse hawkBit™:\nExtensible and configurable software download and installation flows to enable update of any software Ready-to-use script-based software updates to easily implement specific download and install operations, progress tracking, artifact validation, on start up resume and more Flexible file uploads Upload files like logs, configurations, diagnostics, backups and more using backend storage of choice:\nReady-to-use integrations with Azure Cloud Storage and AWS S3 buckets Configuration for periodic uploads or explicitly trigger file upload from the device and more Flexible deployment Choose and combine configurable building blocks deployable on wide range of edge platforms:\nSpecifically optimized for constrained devices to offer compact footprint and optimal utilization of resources Configurable features to allow additional resources allocation fine tuning Ready-to-use builds for Linux ARM, Linux ARM64, Linux x86_64 Integrated with open hardware platforms like Raspberry Pi ","categories":"","description":"About Eclipse Kanto features.\n","excerpt":"About Eclipse Kanto features.\n","ref":"/kanto/about/","tags":"","title":"About"},{"body":"","categories":"","description":"","excerpt":"","ref":"/kanto/categories/","tags":"","title":"Categories"},{"body":"","categories":"","description":"","excerpt":"","ref":"/kanto/docs/","tags":"","title":""},{"body":" Eclipse Kanto Essential IoT enablement for edge devices\ncloud connectivity | local communication | software update | container management Eclipse Kanto™ is a modular IoT edge software that enables devices for IoT with all essentials like cloud connectivity, digital twins, local communication, container management, and software updates - all configurable and remotely manageable by an IoT cloud ecosystem of choice. Benefits Lightweight Lightweight Run Eclipse Kanto on various constrained edge devices with ranging hardware capabilities to scale hardware and enable a seamlessly integrated and harmonized IoT edge landscape.\nRead more Containerized Containerized Develop edge applications by using most fit-for-purpose languages, reliably deploy and manage them as containers leveraging cloud-native technology at the edge.\nRead more Cloud Connected Connected Connect devices to most fit-for-purpose IoT cloud ecosystems to manage devices and device data remotely with minimum customization and prototype quickly.\nRead more Flexible Flexible Choose and combine Eclipse Kanto’s reusable, configurable and interoperable building blocks to bring the right IoT edge capabilities depending on the hardware and use case.\nRead more ","categories":"","description":"","excerpt":" Eclipse Kanto Essential IoT enablement for edge devices\ncloud …","ref":"/kanto/","tags":"","title":"Home"},{"body":"","categories":"","description":"","excerpt":"","ref":"/kanto/search/","tags":"","title":"Search Results"},{"body":"","categories":"","description":"","excerpt":"","ref":"/kanto/tags/","tags":"","title":"Tags"},{"body":"","categories":"","description":"","excerpt":"","ref":"/kanto/year/","tags":"","title":"Year"}]